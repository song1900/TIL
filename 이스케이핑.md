# Escaping

인자로 전달된 클로저가 함수 밖의 변수에 저장되거나 함수가 종료된 뒤 실행되는 클로저를 escaping 클로저라고 합니다.

### non-escaping 클로저

- 함수 내부에서 직접 실행하기 위해서만 사용합니다.
- 따라서 파라미터로 받은 클로저를 변수나 상수에 대입할 수 없습니다.
- 중첩 함수에서 클로저를 사용할 경우, 중첩 함수를 리턴할 수 없습니다.
- 함수의 실행 흐름을 탈출하지 않아, 함수가 종료되기 전에 무조건 실행 되어야 합니다.

### escaping 클로저

- 위 문제들을 해결
    - 변수나 상수에 파라미터로 받은 클로저를 대입할 수 있습니다.
    - 함수가 종료된 후에도 클로저가 실행될 수 있습니다.
    - 함수의 실행 흐름에 상관 없이 실행됩니다.

- escaping 클로저가 클래스 내부의 인스턴스를 참조할 때는 강한 순환 참조를 일으킬 수 있기 때문에 주의가 필요합니.
    - 클로저의 컨택스트 캡처 라는 특성때문에 클래스 내부의 인스턴스를 참조할 때는 강한 순환 참조를 일으켜 메모리 누수를 발생시킬 수 있습니다. 그렇기 때문에 클로저 내부에서는 이를 방지하기 위해 [weak self] 키워드를 사용합니다.
        - weak reference는 실제 객체를 소유하지 않아 레퍼런스 카운트를 증가시키지 않습니다.
        - 이때 참조중인 객체를 strong하게 유지하지 않기 때문에 weak reference가 객체에 대한 참조를 유지 중이여도 deallocate될 수 있습니다. 즉, weak reference는 optional타입으로 nil을 대입할 수 있습니다.
        - 반대로 생각하면 non-escaping 클로저에서는 함수의 scope내에서 모든 작업이 이루어지고 종료되므로 weak reference를 할 필요가 없습니다.