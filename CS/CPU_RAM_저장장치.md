# 컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용할까?

## 역할
1. CPU (Cetnral Processing Unit)
    - 컴퓨터의 "**두뇌**"로서 모든 계산과 명령어 처리를 담당합니다.
2. RAM (Random Access Memory)
    - 임시 저장 장치로, 현재 실행 중인 프로그램과 데이터를 저장합니다.
    - 모든 위치에서 동일한 속도로 접근할 수 있습니다.
3. 저장 장치 (Storage)
    - 데이터를 영구적으로 저장하는 장치입니다.
    - 주요 형태는 HDD와 SDD가 있습니다.

</br>

## 앱 실행 과정을 단계별로 정리
1.  
- 앱을 실행 명령을 내리면 OS는 앱이 설치된 저장 장치에서 앱의 실행 파일과 관련 데이터를 읽어옵니다.
- 이 데이터는 바로 실행되지 않습니다. (RAM로 복사되는 것)
2.  
- 저장 장치에서 읽어온 실행 코드와 데이터는 RAM(메모리)에 로딩
- RAM은 빠른 임시 작업 공간으로, CPU(중앙처리장치)가 직접 데이터를 읽고 쓰는 공간  
- RAM이 없다면? -> CPU는 저장 장치에서 직접 데이터를 가져와야 하므로 성능이 떨어집니다.
3.  
- CPU는 RAM에 있는 앱의 실행 코드를 하나씩 읽어 실행됩니다.
- 프로그램의 흐름에 따라 데이터를 연산하고, 다시 RAM에 결과를 저장하거나 다음 명령을 가져옵니다.
- 이러한 과정이 반복되며 앱이 동작합니다.
4.  
- 앱 실행 중 추가로 필요한 데이터(예: 이미지, DB 등)가 있다면, 다시 저장 장치에서 RAM으로 불러오고, CPU가 이를 처리합니다.
5.  앱이 종료되면 RAM에 적재된 데이터와 코드는 삭제됨  
    변경된 데이터는 저장 장치에 다시 저장되거나, 버려짐


요약하자면,</br>
"앱 실행 시 저장 장치에 데이터를 RAM에 올리고, CPU가 그걸 처리해 실행. 저장 장치는 보관, RAM은 작업 공간, CPU는 실행 담당"


</br>

## 앱을 실행할 때 구성 요소들이 어떤 순서로, 어떻게 상호작용하여 앱 화면을 보여줄까?

**앱 실행 시 화면 출력까지의 구성 요소 상호 작용 순서**
1.  앱 아이콘 클릭
2.  운영체제(OS)가 앱 실행 요청을 처리.  
    - OS는 앱의 "실행 파일과 리소스(이미지, 코드 등)"를 "저장 장치(SSD/HDD)"에서 찾는다
3.  저장 장치 ➡️ RAM: 앱 로딩
    -   앱 실행에 필요한 코드와 데이터가 **RAM으로 복사**된다.
    -   RAM은 CPU가 빠르게 접근할 수 있는 작업 공간이기 때문.
4.  RAM ↔️  CPU: 명령 실행
    -   CPU는 RAM에 로드된 앱의 코드(명령어)를 하나씩 실행한다.
    -   예: "UI를 그려라", "API 요청을 보내라" 등
5.  CPU ➡️ GPU: UI 그리기 요청
    -   CPU는 화면에 무엇을 어떻게 그릴지 결정한 후, GPU(그래픽 처리 장치)에 명령을 보내 UI를 랜더링한다.
6.  GPU ➡️ 디스플레이: 화면 출력
    -   GPU는 계산된 그래픽 정보를 "디스플레이 장치(화면)"에 전달하여 사용자가 볼 수 있는 앱 UI를 실제로 화면에 출력한다.

</br>

## GPU란?
> Graphics Processing Unit  
> GPU는 주로 영상, 이미지, UI 등의 그래픽을 빠르게 계산하고 화면에 출력해주는 전문 프로세서다.

- **CPU와 비교하자면**
    - CPU는 복잡한 논리를 '차례로' 잘 풀고, GPU는 동일 연산을 '동시에' 마구 돌려서 속도를 끌어올린다.
        -   CPU가 논리 연산, 앱 실행 등 컴퓨터의 '두뇌' 역할을 한다면,  
            GPU는 많은 시각 정보를 빠르게 처리하는 '그래픽 전문 계산기'
        -   CPU는 소수의 강력한 코어로 직렬 처리에 최적화되어 있고,   
            GPU는 수천 개의 작업 코어로 병렬 처리에 최적화되어 있다.

- 직렬 처리
    -   작업을 한 번에 하나씩 수행하는 것
    -   CPU가 직렬 처리에 최적화되어 있다 ➡️ 소수의 강력한 코어가 차례차례 명령을 실행한다.
    -   예) "문서 열고 -> 내용 읽고 -> 맞춤법 검사 -> 저장"을 단계별로 수행

- 병렬 처리
    -   여러 작업을 동시에 쪼개서 수행하는 것
    -   GPU가 병렬 처리에 최적화되어 있다 ➡️ 수천 개의 코어가 한꺼번에 픽셀,벡터,행렬을 처리한다.
    -   예) 사진 필터를 적용할 때 각 픽셀을 동시에 바꿈

</br>

### **RAM이 부족하면 iOS 시스템은 어떤 동작을 할까?**

1.  iOS는 앱이 너무 많은 메모리를 사용하면 우선 Memory Warning을 보낸다.
2.  RAM이 계속 부족하면, iOS는 백그라운드에 있는 앱부터 종료시킨다.  
    1.  종료시킨 앱을 재실행하면 cold start로 동작한다.  
        ❗️cold start는 앱이 백그라운드에 남아있지 않고, 처음부터 메모리에 로드되어 실행되는 과정을 말한다.  
             반대로 hot starts는 앱이 백그라운드에 남아 있는 상태에서 다시 복원되는 과정.
3.  메모리 경고를 무시하거나 리소스를 정리하지 못하면, 현재 실행 중인 포그라운드 앱도 강제 종료 (Crash) 시킨다.

### **CPU 속도, RAM 용량, 저장 장치 속도 중 어떤 것이 앱의 '체감 속도'에 가장 큰 영향을 미칠 수 있을까?**

1.  **저장 장치 속도**
    -   앱을 실행하거나 화면 전환이 느릴 때 체감 속도에 가장 큰 영향을 준다.
    -   우선 앱을 실행할 때 리소스를 저장 장치에서 RAM으로 로드시켜야 한다.
    -   저장 장치가 느리면 앱 실행, 화면 로딩, 이미지 로드가 오래 걸리니 사용자 입장에서 체감 속도가 떨어진다.
2.  **CPU 속도**
    -   화면 전환, 애니메이션 부드러움에 영향을 준다.
    -   앱의 코드를 해석하고 UI를 구성하는 것이 CPU의 역할인데 CPU가 느리다면 리스트 스크롤, 애니메이션 등이 끊기게된다.
3.  **RAM 용량**
    -   앱 전환 속도, 백그라운드 유지, 멀티태스킹에 영향을 준다.
    -   RAM이 넉넉하다면 앱을 백그라운드에 계속 유지할 수 있어 hot start가 가능하다.


</br>


### **iOS의 A-시리즈 칩셋에서 CPU와 GPU가 메모리를 공유하는 UMA가 앱 개발에 미치는 영향은 무엇일까?**

> 👉 A-시리즈 칩셋은 Apple의 디바이스에 탑재하는 자체 설계 모바일 프로세스(SoC)  
>    ※ CPU, GPU, Neural Engine, ISP, 메모리 컨트롤 등을 하나로 통합  
>       -> Neural Engine: 인공지능 가속기로, 언어 감지, 텍스트 번역, 객체 추출, 객체 감지 등 다양한 기능을 수행  
>       -> ISP: 카메라 이미지 처리, HDR, 심도 계산 등  
> [출처: 나무위키](https://namu.wiki/w/Apple%20Silicon/A%20%EC%8B%9C%EB%A6%AC%EC%A6%88)

</br>

#### UMA란?

> Unified Memory Architecture(통합 메모리 구조)

CPU와 GPU가 별도의 메모리를 쓰지 않고, 하나의 메모리(RAM)를 공유하는 구조.

- 기존 PC나 일부 안드로이드 SoC는 CPU와 GPU가 각자 메모리 영역을 따로 가짐

- Apple의 UMA는 CPU-GPU-ML 엔진이 모두 하나의 물리적 메모리 풀에 접근함

</br>

#### 그래서 UMA가 앱 개발에 미치는 영향은?

> CPU, GPU가 메모리를 공유함으로써 복사 비용을 줄이고, 성능과 메모리 효율을 높여 앱을 더 빠르고 효율적으로 동작하게 해줌.

1.  데이터 복사 비용 감소 ➡️ 성능 향상  
    - 기존에는 CPU에서 계산한 데이터를 GPU가 사용하려면 복사가 필요햇음.
    -   UMA는 복사 없이 같은 메모리를 직접 공유하므로   
        👉 랜더링 속도가 발라지고, 전력 소비가 감소
2.  메모리 사용량 감소
    -   복사된 버퍼를 만들지 않아도 되므로 전체 메모리 사용량이 줄어듦
    -   즉, 동일 작업을 하더라도 RAM 부담이 덜함
3.  코드 간소화
    -   Metal이나 Core ML 등 프레임워크에서 버퍼 전환/복사에 신경 쓸 필요가 줄어듦
4.  실시간 처리 유리
    -   ARKit, Vision, Core ML 등에서 카메라 이미지 -> 처리 -> 렌더링이 일어나는데 UMA 덕분에 중간 버퍼 복사 없이 더 빠른 실시간 반응이 가능하다.
    -   특히 머신러닝과 AR을 동시에 사용하는 앱에서 큰 이점